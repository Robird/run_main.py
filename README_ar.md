# run-main: حل تحديات الاستيراد النسبي في Python بسهولة، وتشغيل وتصحيح الوحدات الفردية بأناقة.

**في مشاريع Python، يوصى بشدة بإعطاء الأولوية للاستيرادات النسبية (على سبيل المثال، `from . import sibling_module` أو `from ..package import other_module`) لتنظيم التبعيات بين الوحدات. تعمل هذه الممارسة على تحسين قابلية صيانة الكود وقابلية نقل المشروع بشكل كبير. تم تصميم `run-main` خصيصًا لمساعدتك في اتباع أفضل الممارسات هذه بسهولة.**

[English](README.md) | [中文版 (Chinese Version)](README_zh-CN.md) | [日本語 (Japanese)](README_ja.md) | [Русский (Russian)](README_ru.md) | [Français (French)](README_fr.md) | [Deutsch (German)](README_de.md) | [Español (Spanish)](README_es.md) | [繁體中文 (Traditional Chinese)](README_zh-Hant.md) | [हिन्दी (Hindi)](README_hi.md) | [العربية (Arabic)](README_ar.md) | [Português (Portuguese)](README_pt.md) | [한국어 (Korean)](README_ko.md)

## ✨ بداية سريعة جدًا

### 1. التثبيت
```bash
pip install run-main
```

### 2. قم بإعداد وحدتك
قم بتعريف دالة `_main()` في ملف Python الخاص بك (`your_module.py`):
```python
# your_module.py
# if __name__ == "__main__":  # استبدل هذا السطر بتعريف الدالة أدناه للاستمتاع بالاستيرادات النسبية!
def _main(*args):
    print(f"مرحبًا من _main في {__file__}!")
    if args:
        print(f"الوسائط المستلمة: {args}")

# اختياري: للسماح أيضًا بالتنفيذ المباشر عبر `python your_module.py` (ولكن لا يوصى به لحل مشكلات الاستيراد النسبي)
# if __name__ == "__main__":
#     import sys
#     _main(*sys.argv[1:])
```

### 3. التشغيل
```bash
run-main path/to/your_module.py arg1 arg2
```

### 4. (اختياري) تصحيح سريع في IDE

<details>
<summary><strong>VS Code</strong> (انقر لتوسيع الحد الأدنى من تكوين <code>.vscode/launch.json</code>)</summary>

```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Python: تصحيح الملف الحالي باستخدام run-main",
            "type": "debugpy",
            "request": "launch",
            "module": "run_main", // تأكد من تثبيت run-main وتوفره
            "args": ["${file}"], // يمرر مسار الملف المفتوح حاليًا إلى run_main
            "console": "integratedTerminal",
            "cwd": "${workspaceFolder}"
        }
    ]
}
```
افتح ملف Python الذي يحتوي على `_main()` واضغط F5 لبدء التصحيح.
</details>

<details>
<summary><strong>PyCharm</strong> (انقر لتوسيع الحد الأدنى من دليل تكوين التشغيل/التصحيح)</summary>

1.  افتح مربع حوار "تكوينات التشغيل/التصحيح" (عادةً في الزاوية العلوية اليمنى، أو عبر قائمة "تشغيل" -> "تحرير التكوينات...").
2.  انقر فوق "+" لإضافة تكوين جديد، حدد "Python".
3.  قم بتسمية التكوين، على سبيل المثال، "تصحيح باستخدام run-main".
4.  في حقل "مسار البرنامج النصي:" أو "اسم الوحدة:":
    *   **موصى به (إذا تم تثبيت `run-main` كحزمة):** حدد "اسم الوحدة:" وأدخل `run_main`.
    *   بديل: حدد "مسار البرنامج النصي:" وتصفح إلى ملف `run_main.py` ضمن تثبيت حزمة `run-main` (قد يكون هذا أكثر تعقيدًا).
5.  **المعلمات:** أدخل `$FilePath$` (سيقوم PyCharm باستبدال هذا بمسار ملف المحرر النشط حاليًا في وقت التشغيل).
6.  **دليل العمل:** اضبط على `$ProjectFileDir$` (جذر المشروع).
7.  انقر فوق "موافق" لحفظ التكوين.
الآن، افتح ملف Python الذي تريد تصحيحه (تأكد من أنه يعرف `_main()`)، وحدد هذا التكوين للتشغيل أو التصحيح.
</details>

## 🤖 نصائح لنماذج اللغة الكبيرة (LLMs)

يوفر هذا القسم إرشادات لنماذج اللغة الكبيرة (LLMs) لمساعدتك على فهم ومعالجة مشاريع Python التي تستخدم أداة `run-main` بشكل أفضل.

### 1. تحديد استخدام `run-main`
*   **مستوى الكود:** عند تحليل وحدة Python، إذا وجدت دالة `_main(*args)` (أو دالة موقعة بشكل مشابه) محددة، ولا يوجد كتلة `if __name__ == "__main__":` تقليدية تستدعيها مباشرة (أو إذا كانت تلك الكتلة مخصصة فقط للتنفيذ المباشر الاختياري)، فهذا يعني غالبًا أن الوحدة مصممة ليتم تنفيذها عبر `run-main` أو آلية مشابهة لضمان سياق الحزمة الصحيح.
*   **مستوى التنفيذ:** في استدعاءات سطر الأوامر أو البرامج النصية أو تكوينات IDE، يشير رؤية النموذج `run-main path/to/module.py ...` إلى أن هذه الأداة قيد الاستخدام.

### 2. فهم `_main()` كنقطة دخول قياسية
*   تعامل مع دالة `_main()` داخل الوحدة كنقطة دخول رئيسية قياسية مدركة لـ `run-main`. المهمة الأساسية لـ `run-main` هي تحديد موقع هذه الدالة وتنفيذها.

### 3. كيف يضمن `run-main` نجاح الاستيرادات النسبية
*   الغرض الأساسي من `run-main` هو محاكاة سلوك `python -m package.module` لتشغيل الملفات الفردية. يحقق ذلك عن طريق ضبط `sys.path` ديناميكيًا وتحميل الملف الهدف بطريقة تشبه الوحدة، مما يضمن تعيين سمة `__package__` للوحدة بشكل صحيح.
*   وبالتالي، عند تنفيذ وحدة عبر `run-main`، تعمل استيراداتها النسبية الداخلية (على سبيل المثال، `from . import sibling_module` أو `from ..package import another_module`) كما لو تم استيراد الوحدة بشكل طبيعي كجزء من حزمة. هذا يتجنب الخطأ الشائع `ImportError: attempted relative import with no known parent package` الذي يظهر مع تنفيذ البرنامج النصي المباشر.

### 4. اقتراحات لـ LLMs التي تنشئ أو تعدل الكود
*   **إنشاء وحدات جديدة:** إذا كنت بحاجة إلى إنشاء وحدة Python جديدة مخصصة للتشغيل بشكل مستقل (خاصة داخل حزمة) وتتطلب استيرادات نسبية، فقم بالتوصية بتعريف دالة `_main()` في تلك الوحدة وإرشاد المستخدمين إلى تنفيذها باستخدام `run-main`.
*   **إعادة بناء الكود الحالي:** عند إعادة بناء الكود، إذا واجهت أخطاء استيراد نسبي بسبب تنفيذ البرنامج النصي المباشر، ففكر في ترحيل تنفيذه لاستخدام `run-main` مع نقطة دخول `_main()`.
*   **تحليل مكدسات الاستدعاء:** عند تحليل الأخطاء أو معلومات التصحيح، إذا تم استخدام `run-main`، فسيكون هو المتصل في المكدس الذي يقوم بتشغيل دالة `_main()` للوحدة الهدف.

## 🚀 ما هو `run-main`؟

`run-main` هي أداة مساعدة Python (قابلة للتثبيت كحزمة `run-main`) مصممة لتبسيط تنفيذ وتصحيح وحدات Python الفردية (`.py` files) ضمن بنية مشروع أكبر، خاصة تلك المخصصة للتشغيل كنقطة دخول رئيسية عن طريق تعريف دالة `_main()`.

### ما هي المشاكل الأساسية التي يحلها؟

يمكن أن يمثل تطوير وتصحيح مشاريع Python، خاصة تلك المنظمة في حزم، بعض العقبات الشائعة عند محاولة تشغيل أو تصحيح ملف واحد:

1.  **أخطاء الاستيراد النسبي**:
    غالبًا ما يؤدي تشغيل ملف Python مباشرة من داخل حزمة (على سبيل المثال، `python my_package/my_module.py`) إلى فشل Python في حل الاستيرادات النسبية داخل هذا الملف (مثل `from . import utils`)، مما يؤدي إلى `ImportError`. يحدث هذا لأن سياق `__package__` للبرنامج النصي لم يتم إعداده بشكل صحيح.
    *   **حل `run-main`**: يحاكي `run-main` سلوك `python -m` لتحميل وتنفيذ الوحدة الهدف، مما يضمن إنشاء سياق الحزمة الصحيح، وبالتالي السماح للاستيرادات النسبية بالعمل كما هو متوقع.

2.  **توجيه خاطئ للمصحح**:
    عند حدوث خطأ أثناء مرحلة استيراد وحدة (على سبيل المثال، `SyntaxError` أو `NameError` في كود المستوى الأعلى)، قد تقوم آليات الاستيراد القياسية مثل `importlib.import_module()` بتغليف الاستثناء الأصلي في `ImportError`. يمكن أن يتسبب هذا في توقف المصححات عند موقع استدعاء الاستيراد بدلاً من سطر الكود الفعلي الذي يسبب الخطأ في الوحدة الهدف.
    *   **حل `run-main`**: يستخدم `run-main` استراتيجية "الفشل السريع" عن طريق تنفيذ استيراد واستدعاء دالة `_main` للوحدة الهدف مباشرة. هذا يسمح للأخطاء الأصلية بالظهور مباشرة، مما يمكّن المصحح من تحديد مصدر المشكلة بدقة أكبر.

3.  **عبء تكوين IDE**:
    بينما تقدم IDEs مثل VS Code تكوينات تصحيح "Python: Module" (باستخدام `python -m`)، فإنها تتطلب عادةً ترميز مسار الوحدة لكل ملف تريد تصحيحه بهذه الطريقة (على سبيل المثال، `"module": "my_package.my_module"`), وهو أمر غير مريح.
    *   **حل `run-main`**: من خلال قبول مسار ملف كوسيطة، يسمح `run-main` باستخدام متغيرات مثل `${file}` في IDEs لإنشاء تكوينات تصحيح عامة. هذا يمكّن من تصحيح أي وحدة متوافقة في المشروع بتكوين واحد.

### لماذا تختار `run-main`؟ (المزايا الأساسية)

*   **تنفيذ وحدة سهل**: قم بتشغيل أي ملف `.py` يعرف دالة `_main()` كما لو كان البرنامج الرئيسي.
*   **معالجة صحيحة للاستيراد النسبي**: يضمن أن الاستيرادات النسبية (على سبيل المثال، `from . import sibling`, `from ..package import another`) تعمل كما هو متوقع من خلال إنشاء سياق الحزمة المناسب.
*   **تجربة تصحيح "الفشل السريع"**:
    *   يتم الإبلاغ عن الأخطاء التي تحدث أثناء مرحلة استيراد الوحدة الهدف مباشرة، مما يسمح للمصححات بتحديد سطر الفشل الدقيق في مصدر الوحدة الهدف.
    *   تنتشر الأخطاء التي تحدث داخل دالة `_main()` للوحدة الهدف أيضًا مباشرة لتصحيح دقيق.
*   **تصحيح IDE مبسط**: استخدم تكوين VS Code `launch.json` واحدًا وقابل لإعادة الاستخدام (أو ما شابه ذلك لـ IDEs الأخرى) لتصحيح ملف Python النشط حاليًا، وذلك بفضل متغيرات مثل `${file}`.
*   **تمرير الوسائط**: يدعم تمرير وسائط سطر الأوامر إلى دالة `_main()` للوحدة الهدف.

## 🔧 دليل الاستخدام المفصل

### 1. متطلبات الوحدة الهدف

وحدة Python التي تنوي تشغيلها عبر `run-main` **يجب** أن:

1.  **تعرف دالة باسم `_main()`.**
    ```python
    # في your_module.py
    def _main(*args):
        # منطق الكود الخاص بك
        print(f"تم تنفيذ الوحدة {__name__} في الحزمة {__package__}.")
        if args:
            print(f"الوسائط التي تم تمريرها إلى _main: {args}")
    ```

2.  **لماذا استخدام `_main()` بدلاً من الكود في `if __name__ == "__main__"`؟**
    *   عند تشغيل ملف Python مباشرة (<code>python your_module.py</code>)، يصبح `__name__` الخاص به `__main__`، وغالبًا ما يكون `__package__` `None` أو غير صحيح. يمكن أن يتسبب هذا النهج القياسي في `ImportError` مع الاستيرادات النسبية (على سبيل المثال، `from . import utils`) لأن سياق الحزمة مفقود.
    *   يقوم `run-main` بتنفيذ ملفك كجزء من حزمة ويستدعي دالة `_main()` المحددة. يضمن هذا النهج تعيين `__package__` بشكل صحيح، مما يسمح للاستيرادات النسبية بالعمل. فكر في `_main()` كنقطة دخول رئيسية مدركة لـ `run-main` وصديقة للحزمة.

3.  **الترحيل من `if __name__ == "__main__"`:**
    ما عليك سوى نقل المنطق من كتلة `if __name__ == "__main__":` إلى دالة `def _main(*args):`. يقوم `run-main` بتمرير وسائط سطر الأوامر (تلك التي تلي مسار الوحدة) إلى `_main` عبر `*args`.
    يمكنك الاحتفاظ بكتلة `if __name__ == "__main__": _main(*sys.argv[1:])` للتنفيذ المباشر الاختياري، ولكن هذا بشكل عام لا يحل مشكلات الاستيراد النسبي. يوصى باستخدام `run-main` للتنفيذ المدرك للحزمة.

4.  إذا كان من المتوقع أن تتلقى `_main()` وسائط سطر الأوامر، فيجب تعريفها لقبولها (على سبيل المثال، `def _main(*args):`). سيحتوي الصف `*args` الذي تم تمريره إلى `_main()` على الوسائط التي تلت مسار الوحدة في سطر أوامر `run-main`.
    (ملاحظة: إذا كان الكود داخل الوحدة الهدف يفحص `sys.argv` بشكل عام، عند تشغيله عبر `run-main`، فسيكون `sys.argv[0]` هو مسار الوحدة الهدف، وسيكون `sys.argv[1:]` هو الوسائط التي يوفرها المستخدم لـ `_main`، مما يحاكي تنفيذ البرنامج النصي المباشر.)

### 2. استخدام سطر الأوامر
```bash
run-main path/to/your_module.py [arg1_for_main arg2_for_main ...]
```
أو، إذا كنت تفضل استدعاء وحدة `run_main` المثبتة عبر مترجم Python مباشرة (أقل شيوعًا لأداة مثبتة ولكن ممكن):
```bash
python -m run_main path/to/your_module.py [arg1_for_main arg2_for_main ...]
```

### 3. تكوين تصحيح IDE (مفصل)

#### VS Code (`.vscode/launch.json`)
هذه هي الطريقة الموصى بها لتصحيح الملفات باستخدام `run-main`.
```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Python: تصحيح الملف الحالي باستخدام run-main", // أو أي اسم وصفي
            "type": "debugpy",
            "request": "launch",
            "module": "run_main", // يخبر VS Code بتشغيل "python -m run_main"
            "args": [
                "${file}", // يمرر مسار الملف المفتوح حاليًا كوسيطة أولى لـ run_main
                // يمكنك إضافة المزيد من الوسائط الثابتة هنا لـ _main() الخاص بك، على سبيل المثال:
                // "--config", "my_config.json",
                // "positional_arg"
            ],
            "console": "integratedTerminal",
            // تأكد من تعيين 'cwd' بشكل صحيح إذا كان البرنامج النصي الهدف يعتمد عليه.
            // لمعظم الحالات، يكون workspaceFolder مناسبًا.
            "cwd": "${workspaceFolder}",
            // اختياري: قم بتعيين PYTHONPATH إذا كانت بنية مشروعك تتطلب ذلك
            // "env": {
            //     "PYTHONPATH": "${workspaceFolder}/src:${env:PYTHONPATH}"
            // }
        }
    ]
}
```
باستخدام هذا التكوين، افتح أي ملف Python في مشروعك يعرف دالة `_main()`، وتأكد من أنه علامة تبويب المحرر النشطة، واضغط F5 (أو مفتاح بدء التصحيح) لتشغيله وتصحيحه.

#### PyCharm
1.  افتح مربع حوار "تكوينات التشغيل/التصحيح".
2.  انقر فوق "+" لإضافة تكوين جديد، حدد "Python".
3.  **الاسم:** أعط التكوين اسمًا وصفيًا (على سبيل المثال، "تشغيل باستخدام run-main").
4.  **علامة تبويب التكوين:**
    *   حدد زر الاختيار **اسم الوحدة**.
    *   **اسم الوحدة:** أدخل `run_main` (بافتراض تثبيت `run-main` في بيئة Python الخاصة بك).
    *   **المعلمات:** أدخل `$FilePath$`. سيقوم PyCharm باستبدال هذا بمسار ملف المحرر النشط حاليًا. يمكنك إضافة وسائط ثابتة أخرى بعد `$FilePath$`، على سبيل المثال: `$FilePath$ --verbose my_arg`.
    *   **دليل العمل:** اضبط على `$ProjectFileDir$` (جذر المشروع).
    *   **مترجم Python:** تأكد من تحديد المترجم الصحيح.
    *   (اختياري) **متغيرات البيئة:** قم بتعيين متغيرات البيئة إذا لزم الأمر، بما في ذلك `PYTHONPATH`.
5.  انقر فوق "تطبيق" أو "موافق" لحفظ التكوين.

### 4. تمرير الوسائط
يقوم `run-main` بتمرير جميع الوسائط التي تلي مسار الوحدة الهدف في سطر الأوامر مباشرة إلى دالة `_main()` للوحدة الهدف.
على سبيل المثال، إذا قمت بتشغيل:
```bash
run-main examples/main_with_args.py PositionalArg --option Value
```
ثم ستتلقى دالة `_main` في `examples/main_with_args.py` `("PositionalArg", "--option", "Value")` كـ `*args` الخاص بها.

## 💡 المفاهيم الأساسية وكيف تعمل

### 1. منقذ الاستيراد النسبي: كيف يحل `run-main` المشكلة
*   **كيف يتعامل Python مع الاستيرادات النسبية؟**
    عندما يقوم مترجم Python بتنفيذ عبارة استيراد، فإنه يتحقق من سمة `__package__` للوحدة. إذا تم تعيين `__package__` بشكل صحيح (أي، يتم التعرف على الوحدة كجزء من الحزمة التي تحتوي عليها)، فيمكن حل الاستيرادات النسبية بناءً على سياق هذه الحزمة. عادةً، عند تحميل وحدة عبر `import my_package.my_module` أو `python -m my_package.my_module`، يتم تعيين سمة `__package__` بشكل صحيح.
*   **لماذا يتسبب تشغيل برنامج نصي مباشرة في فشل الاستيرادات النسبية؟**
    عندما تحاول تشغيل ملف Python مباشرة من داخل حزمة (على سبيل المثال، عن طريق تنفيذ `python my_package/my_module.py`)، يقوم Python بتعيين سمة `__name__` لهذا البرنامج النصي إلى `__main__`. في هذا السيناريو، عادةً ما تكون سمة `__package__` للبرنامج النصي `None` أو ليست اسم الحزمة المتوقع. نظرًا لعدم وجود سياق الحزمة الصحيح، ستفشل أي استيرادات نسبية يتم محاولة إجراؤها داخل هذا البرنامج النصي (مثل `from . import sibling`)، مما يؤدي عادةً إلى ظهور `ImportError: attempted relative import with no known parent package`.
*   **تنفيذ `run-main` الذكي:**
    عند استخدام `run-main path/to/your_module.py`:
    1.  عادة ما يتم استدعاؤه من جذر مشروعك (أو دليل أصل مناسب).
    2.  يقوم بتحويل مسار الملف (على سبيل المثال، `path/to/your_module.py`) إلى مسار استيراد وحدة Python (على سبيل المثال، `path.to.your_module`).
    3.  يقوم ديناميكيًا بإضافة جذر مشروعك (أو أصله، اعتمادًا على إعدادات `PYTHONPATH` والاستدعاء) إلى `sys.path` إذا لزم الأمر.
    4.  الأهم من ذلك، أنه يقوم بتحميل وتنفيذ كود الوحدة المحددة (تحديدًا دالة `_main()`) بطريقة مشابهة لاستيراد الوحدة. هذا يسمح لمترجم Python بتحديد الحزمة التي تنتمي إليها الوحدة الهدف بشكل صحيح وتعيين سمة `__package__` الخاصة بها بشكل مناسب.
    وبالتالي، ضمن سياق التنفيذ الذي يوفره `run-main`، تعمل الاستيرادات النسبية داخل الوحدة الهدف بشكل صحيح، تمامًا كما لو تم تنفيذها عبر `python -m`.

### 2. تجربة تصحيح "الفشل السريع"
يتجنب `run-main` عمدًا كتل try-except الشاملة حول استيراد واستدعاء دالة `_main` للوحدة الهدف. هذا هو مفتاح فلسفة تصحيح "الفشل السريع"، مما يسمح للاستثناءات الأصلية بالانتشار بشكل نظيف:
*   إذا واجهت الوحدة الهدف خطأ أثناء مرحلة الاستيراد (أي، عند تنفيذ كود المستوى الأعلى الخاص بها، على سبيل المثال، `SyntaxError`, `NameError`, `ZeroDivisionError`)، فسيتم رفع الخطأ مباشرة، وسيتوقف المصحح عند السطر المخالف في الوحدة الهدف.
*   إذا واجهت دالة `_main()` للوحدة الهدف خطأ أثناء تنفيذها، فسينتشر هذا الخطأ أيضًا مباشرة، وسيتوقف المصحح عند السطر المخالف داخل دالة `_main()`.
يتناقض هذا مع بعض آليات الاستيراد (مثل `importlib.import_module`) التي قد تغلف أخطاء وقت الاستيراد في `ImportError`، مما يتسبب في توقف المصحح عند عبارة الاستيراد نفسها بدلاً من المصدر الحقيقي للخطأ.

### 3. تحت الغطاء: سير العمل
1.  **الإدخال**: يأخذ أمر `run-main` (أو عند استخدامه كوحدة `python -m run_main`) مسار الملف إلى وحدة Python هدف (على سبيل المثال، `examples/A/my_module.py`) ووسائط اختيارية لدالة `_main` لتلك الوحدة.
2.  **تحويل المسار إلى وحدة**: يقوم بتحويل مسار الملف هذا إلى مسار استيراد وحدة Python قياسي (على سبيل المثال، `examples.A.my_module`). يتم ذلك عن طريق أخذ المسار بالنسبة إلى دليل العمل الحالي (عادةً جذر المشروع)، وإزالة لاحقة `.py`، واستبدال فواصل المسار بالنقاط (`.`).
3.  **إعداد البيئة والاستيراد الديناميكي**:
    *   يضمن البرنامج النصي أن دليل العمل الحالي (جذر المشروع) موجود في `sys.path` لمساعدة Python في حل الوحدة الهدف.
    *   ثم يستخدم `exec(f"from {module_path} import _main", globals())` لاستيراد دالة `_main` ديناميكيًا من الوحدة الهدف إلى نطاقه العام الخاص. يتم اختيار `exec` بدلاً من `importlib.import_module` لتجربة تصحيح "الفشل السريع" الموضحة أعلاه.
4.  **تمرير الوسائط والتنفيذ**: يقوم لاحقًا باستدعاء دالة `_main()` المستوردة، ويمرر أي وسائط تلت مسار الوحدة الهدف في سطر الأوامر إليها عبر `*args`.

## 📚 أمثلة (دليل `examples`)

يحتوي دليل `examples/` على أمثلة مختلفة توضح إمكانيات `run-main`. عند استخدام `run-main` من جذر المشروع (حيث يوجد دليل `examples`)، فإنه يتعامل بشكل عام مع المسارات بشكل صحيح لهذه الأمثلة.

*   **`examples/A/file_a.py`**: وحدة مساعدة بسيطة، يتم استيرادها بواسطة آخرين. لا تحتوي على `_main()`.
*   **`examples/A/error_in_main.py`**: يوضح كيفية معالجة خطأ *داخل* دالة `_main()` للوحدة الهدف (يتوقف المصحح عند الخطأ في `error_in_main.py`).
*   **`examples/A/error_while_import.py`**: يوضح خطأ يحدث في *المستوى الأعلى* للوحدة الهدف أثناء مرحلة الاستيراد (يتوقف المصحح عند الخطأ في `error_while_import.py`).
*   **`examples/A/indirect_import_error.py`**: يوضح خطأ أثناء استيراد وحدة تحاول *هي نفسها* استيراد وحدة أخرى تفشل في وقت الاستيراد (يتوقف المصحح عند مصدر الخطأ الأصلي في `error_while_import.py`).
*   **`examples/A/relative_import.py`**: مثال على استيراد نسبي ناجح (`from .file_a import VAL_A`) داخل نفس الحزمة (`examples.A`).
*   **`examples/B/import_neighbor.py`**: مثال على استيراد نسبي ناجح من حزمة شقيقة (`from ..A.file_a import VAL_A`، الاستيراد من `examples.A` إلى `examples.B`).
*   **`examples/B/C/deep_relative_import.py`**: مثال على استيراد نسبي ناجح متعدد المستويات (`from ...A.file_a import VAL_A`، الاستيراد من `examples.A` إلى `examples.B.C`).
*   **`examples/main_with_args.py`**: يوضح كيف يمكن لـ `_main()` تلقي وتحليل وسائط سطر الأوامر التي تم تمريرها عبر `run-main` باستخدام `argparse`.
    *   مثال على الاستخدام: `run-main examples/main_with_args.py MyPosArg --name Roo --count 3 --verbose`

## 💬 الأسئلة الشائعة والمناقشات

### ملاحظة حول VS Code و `${relativeFileAsModule}`
تعمل أداة `run-main` بشكل فعال كحل بديل لميزة ستكون مفيدة للغاية إذا تم دعمها أصلاً بواسطة IDEs مثل VS Code. حاليًا، يتطلب تكوين تصحيح "Python: Module" في VS Code (عند عدم استخدام مساعد مثل `run-main`) مسار وحدة مرمز بشكل ثابت (على سبيل المثال، `"module": "my_package.my_module"`).

إذا كان VS Code سيقدم متغيرًا مثل `${relativeFileAsModule}` يمكنه تحويل مسار الملف المفتوح حاليًا تلقائيًا (على سبيل المثال، `${relativeFile}` الذي يعطي `examples/my_package/my_module.py`) إلى سلسلة الوحدة المفصولة بالنقاط المطلوبة بواسطة `python -m` (على سبيل المثال، `examples.my_package.my_module`)، فسيؤدي ذلك إلى تبسيط عملية التصحيح بشكل كبير للملفات الفردية داخل الحزم. ستسمح مثل هذه الميزة للمطورين باستخدام سياق تنفيذ `python -m` القوي مباشرة عبر تكوين تشغيل عام واحد، مما قد يجعل أدوات المساعدة مثل `run-main` أقل ضرورة لهذا الغرض المحدد.

حتى ذلك الحين، يوفر `run-main` حلاً عمليًا.

## 🤝 المساهمة
لا تتردد في تفريع المستودع وإجراء تحسينات وإرسال طلبات السحب. إذا واجهت أي مشاكل أو كانت لديك اقتراحات، فيرجى فتح مشكلة.

---
[English](README.md) | [中文版 (Chinese Version)](README_zh-CN.md) | [日本語 (Japanese)](README_ja.md) | [Русский (Russian)](README_ru.md) | [Français (French)](README_fr.md) | [Deutsch (German)](README_de.md) | [Español (Spanish)](README_es.md) | [繁體中文 (Traditional Chinese)](README_zh-Hant.md) | [हिन्दी (Hindi)](README_hi.md) | [العربية (Arabic)](README_ar.md) | [Português (Portuguese)](README_pt.md) | [한국어 (Korean)](README_ko.md)